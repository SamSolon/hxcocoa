//
//  PiratePigGame
//  PiratePig
//
//  Source generated by Haxe Objective-C target
//

#import "PiratePigGame.h"

@implementation PiratePigGame

static int NUM_COLUMNS;
+ (int) NUM_COLUMNS {
	if (NUM_COLUMNS == nil) NUM_COLUMNS = 8;
	return NUM_COLUMNS;
}
+ (void) setNUM_COLUMNS:(int)hx_val {
	NUM_COLUMNS = hx_val;
}
static int NUM_ROWS;
+ (int) NUM_ROWS {
	if (NUM_ROWS == nil) NUM_ROWS = 8;
	return NUM_ROWS;
}
+ (void) setNUM_ROWS:(int)hx_val {
	NUM_ROWS = hx_val;
}
static NSMutableArray* tileImages;
+ (NSMutableArray*) tileImages {
	if (tileImages == nil) tileImages = [@[[@"game_bear.png" mutableCopy], [@"game_bunny_02.png" mutableCopy], [@"game_carrot.png" mutableCopy], [@"game_lemon.png" mutableCopy], [@"game_panda.png" mutableCopy], [@"game_piratePig.png" mutableCopy]] mutableCopy];
	return tileImages;
}
+ (void) setTileImages:(NSMutableArray*)hx_val {
	tileImages = hx_val;
}
@synthesize Background;
@synthesize Logo;
@synthesize Score;
@synthesize TileContainer;
@synthesize currentScale;
@synthesize currentScore;
@synthesize cacheMouse;
@synthesize needToCheckMatches;
@synthesize selectedTile;
@synthesize tiles;
@synthesize usedTiles;
- (void) initialize{
	
	[Log trace:[@"initialize" mutableCopy] infos:@{@"fileName":@"PiratePigGame.hx", @"lineNumber":@"45", @"className":@"PiratePigGame", @"methodName":@"initialize"}];
	self.currentScale = 1;
	self.currentScore = 0;
	self.tiles = [[NSMutableArray alloc] init];
	self.usedTiles = [[NSMutableArray alloc] init];
	{
		
		int _g1 = 0; int _g = PiratePigGame.NUM_ROWS;
		while (_g1 < _g) {
			
			int row = _g1++;
			[self.tiles push:[[NSMutableArray alloc] init]];
			{
				
				int _g3 = 0; int _g2 = PiratePigGame.NUM_COLUMNS;
				while (_g3 < _g2) {
					
					int column = _g3++;
					
					NSMutableArray *t = ((NSMutableArray*)[self.tiles hx_objectAtIndex:row]);
					[t hx_replaceObjectAtIndex:column withObject:[NSNull null]];
				}
			}
		}
	}
	self.Background = [[UIView alloc] init];
	self.Logo = [[UIImageView alloc]  initWithImage:[UIImage imageNamed:[@"logo.png" mutableCopy]]];
	CGRect bs = self.Logo.frame;
	bs.origin.x = 320. - bs.size.width / 2;
	self.Logo.frame = bs;
	self.Score = [[UILabel alloc] init];
	self.Score.frame = CGRectMake(0,0,100,50);
	self.Score.textColor = [UIColor redColor];
	self.Score.backgroundColor = [UIColor clearColor];
	self.Score.textAlignment = NSTextAlignmentLeft;
	self.Score.font = [UIFont boldSystemFontOfSize:30];
	self.TileContainer = [[UIView alloc] init];
}
- (void) construct{
	
	[Log trace:[@"Construct" mutableCopy] infos:@{@"fileName":@"PiratePigGame.hx", @"lineNumber":@"79", @"className":@"PiratePigGame", @"methodName":@"construct"}];
	[self addSubview:self.Logo];
	int contentWidth = 75 * PiratePigGame.NUM_COLUMNS;
	CGRect rect = self.Score.frame;
	rect.origin.x = 0;
	rect.origin.y = 12;
	rect.size.width = 200;
	self.Score.frame = rect;
	[self addSubview:self.Score];
	[self addSubview:self.Background];
	CGRect rect1 = self.TileContainer.frame;
	rect1.origin.x = 14;
	rect1.origin.y = 99;
	self.TileContainer.frame = rect1;
	[self addSubview:self.TileContainer];
}
- (void) newGame{
	
	self.currentScore = 0;
	self.Score.text = [@"0" mutableCopy];
	{
		
		int _g1 = 0; int _g = PiratePigGame.NUM_ROWS;
		while (_g1 < _g) {
			
			int row = _g1++;
			{
				
				int _g3 = 0; int _g2 = PiratePigGame.NUM_COLUMNS;
				while (_g3 < _g2) {
					
					int column = _g3++;
					[self removeTile:row column:column animate:NO];
				}
			}
		}
	}
	{
		
		int _g1 = 0; int _g = PiratePigGame.NUM_ROWS;
		while (_g1 < _g) {
			
			int row = _g1++;
			{
				
				int _g3 = 0; int _g2 = PiratePigGame.NUM_COLUMNS;
				while (_g3 < _g2) {
					
					int column = _g3++;
					[self addTile:row column:column animate:NO];
				}
			}
		}
	}
	
	NSTimer *timer = [NSTimer timerWithTimeInterval:0.2 target:self selector:@selector(loop:) userInfo:nil repeats:YES];
	
	NSRunLoop *runner = [NSRunLoop currentRunLoop];
	[runner addTimer:timer forMode:NSDefaultRunLoopMode];
}
- (NSMutableArray*) findMatches:(BOOL)byRow accumulateScore:(BOOL)accumulateScore{
	
	// Optional arguments
	if (!accumulateScore) accumulateScore = YES;
	
	
	NSMutableArray *matchedTiles = [[NSMutableArray alloc] init];
	int max;
	int secondMax;
	if (byRow) {
		
		max = PiratePigGame.NUM_ROWS;
		secondMax = PiratePigGame.NUM_COLUMNS;
	}
	else {
		
		max = PiratePigGame.NUM_COLUMNS;
		secondMax = PiratePigGame.NUM_ROWS;
	}
	{
		
		int _g = 0;
		while (_g < max) {
			
			int index = _g++;
			int matches = 0;
			
			NSMutableArray *foundTiles = [[NSMutableArray alloc] init];
			int previousType = -1;
			{
				
				int _g1 = 0;
				while (_g1 < secondMax) {
					
					int secondIndex = _g1++;
					
					Tile *tile;
					if (byRow) {
						
						
						NSMutableArray *t = ((NSMutableArray*)[self.tiles hx_objectAtIndex:index]);
						tile = ((NSMutableArray*)[t hx_objectAtIndex:secondIndex]);
					}
					else {
						
						
						NSMutableArray *t = ((NSMutableArray*)[self.tiles hx_objectAtIndex:secondIndex]);
						tile = ((NSMutableArray*)[t hx_objectAtIndex:index]);
					}
					if (tile != nil && !tile.moving) {
						
						if (previousType == -1) {
							
							previousType = tile.type;
							[foundTiles push:tile];
							continue;
						}
						else if (tile.type == previousType) {
							
							[foundTiles push:tile];
							matches++;
						}
					}
					if (tile == nil || tile.moving || tile.type != previousType || secondIndex == secondMax - 1) {
						
						if (matches >= 2 && previousType != -1) {
							
							if (accumulateScore) self.currentScore += [Std _int:powf(matches, 2) * 50];
							matchedTiles = [matchedTiles concat:foundTiles];
						}
						matches = 0;
						foundTiles = [[NSMutableArray alloc] init];
						if (tile == nil || tile.moving) {
							
							self.needToCheckMatches = YES;
							previousType = -1;
						}
						else {
							
							previousType = tile.type;
							[foundTiles push:tile];
						}
					}
				}
			}
		}
	}
	return matchedTiles;
}
- (CGPoint) getPosition:(int)row column:(int)column{
	
	return  CGPointMake(column * 73, row * 73);
}
- (void) addTile:(int)row column:(int)column animate:(BOOL)animate{
	
	// Optional arguments
	if (!animate) animate = YES;
	
	
	Tile *tile = nil;
	int type = roundf(rand() %  ([PiratePigGame.tileImages count] - 1));
	int i = 0;
	
	Tile *usedTile = nil;
	while (i < self.usedTiles.length) {
		
		usedTile = ((Tile*)[self.usedTiles hx_objectAtIndex:i]);
		i++;
	}
	if (tile == nil) tile = [[Tile alloc] init:((NSMutableString*)[PiratePigGame.tileImages hx_objectAtIndex:type])];
	[tile initialize];
	tile.type = type;
	tile.row = row;
	tile.column = column;
	
	NSMutableArray *t = ((NSMutableArray*)[self.tiles hx_objectAtIndex:row]);
	[t hx_replaceObjectAtIndex:column withObject:tile];
	CGPoint position = [self getPosition:row column:column];
	if (animate) {
		
		CGPoint firstPosition = [self getPosition:-1 column:column];
		tile.alpha = 0;
		CGRect rect = tile.frame;
		rect.origin.x = firstPosition.x;
		rect.origin.y = firstPosition.y;
		tile.frame = rect;
		[tile moveTo:0.15 *  (row + 1) targetX:position.x targetY:position.y];
	}
	else {
		
		CGRect rect = tile.frame;
		rect.origin.x = position.x;
		rect.origin.y = position.y;
		tile.frame = rect;
	}
	[self.TileContainer addSubview:tile];
	self.needToCheckMatches = YES;
}
- (void) removeTile:(int)row column:(int)column animate:(BOOL)animate{
	
	// Optional arguments
	if (!animate) animate = YES;
	
	
	NSMutableArray *t = ((NSMutableArray*)[self.tiles hx_objectAtIndex:row]);
	
	Tile *tile = ((NSMutableArray*)[t hx_objectAtIndex:column]);
	if (tile != nil) {
		
		[tile remove:animate];
		[self.usedTiles push:tile];
	}
	[t hx_replaceObjectAtIndex:column withObject:[NSNull null]];
}
- (void) swapTile:(Tile*)tile targetRow:(int)targetRow targetColumn:(int)targetColumn{
	
	[Log trace:[[@"swipe tile " mutableCopy] stringByAppendingString:[Std string:tile]] infos:@{@"fileName":@"PiratePigGame.hx", @"lineNumber":@"321", @"className":@"PiratePigGame", @"methodName":@"swapTile"}];
	if (targetColumn >= 0 && targetColumn < PiratePigGame.NUM_COLUMNS && targetRow >= 0 && targetRow < PiratePigGame.NUM_ROWS) {
		
		[Log trace:[@"ok" mutableCopy] infos:@{@"fileName":@"PiratePigGame.hx", @"lineNumber":@"323", @"className":@"PiratePigGame", @"methodName":@"swapTile"}];
		
		Tile *targetTile = ((NSMutableArray*)[((NSMutableArray*)[self.tiles hx_objectAtIndex:targetRow]) hx_objectAtIndex:targetColumn]);
		[Log trace:[[@"to tile " mutableCopy] stringByAppendingString:[Std string:targetTile]] infos:@{@"fileName":@"PiratePigGame.hx", @"lineNumber":@"325", @"className":@"PiratePigGame", @"methodName":@"swapTile"}];
		if (targetTile != nil && !targetTile.moving) {
			
			[Log trace:[@"ok" mutableCopy] infos:@{@"fileName":@"PiratePigGame.hx", @"lineNumber":@"327", @"className":@"PiratePigGame", @"methodName":@"swapTile"}];
			
			NSMutableArray *t = ((NSMutableArray*)[self.tiles hx_objectAtIndex:targetRow]);
			[t hx_replaceObjectAtIndex:targetColumn withObject:tile];
			t = ((NSMutableArray*)[self.tiles hx_objectAtIndex:tile.row]);
			[t hx_replaceObjectAtIndex:tile.column withObject:targetTile];
			[Log trace:[@"CHECK FOR MATCHES" mutableCopy] infos:@{@"fileName":@"PiratePigGame.hx", @"lineNumber":@"332", @"className":@"PiratePigGame", @"methodName":@"swapTile"}];
			if ([[self findMatches:YES accumulateScore:NO] count] > 0 || [[self findMatches:NO accumulateScore:NO] count] > 0) {
				
				[Log trace:[@"found matches" mutableCopy] infos:@{@"fileName":@"PiratePigGame.hx", @"lineNumber":@"334", @"className":@"PiratePigGame", @"methodName":@"swapTile"}];
				targetTile.row = tile.row;
				targetTile.column = tile.column;
				tile.row = targetRow;
				tile.column = targetColumn;
				CGPoint targetTilePosition = [self getPosition:targetTile.row column:targetTile.column];
				CGPoint tilePosition = [self getPosition:tile.row column:tile.column];
				[targetTile moveTo:0.3 targetX:targetTilePosition.x targetY:targetTilePosition.y];
				[tile moveTo:0.3 targetX:tilePosition.x targetY:tilePosition.y];
				self.needToCheckMatches = YES;
			}
			else {
				
				[Log trace:[@"matches not found" mutableCopy] infos:@{@"fileName":@"PiratePigGame.hx", @"lineNumber":@"348", @"className":@"PiratePigGame", @"methodName":@"swapTile"}];
				
				NSMutableArray *t1 = ((NSMutableArray*)[self.tiles hx_objectAtIndex:targetRow]);
				[t1 hx_replaceObjectAtIndex:targetColumn withObject:targetTile];
				t1 = ((NSMutableArray*)[self.tiles hx_objectAtIndex:tile.row]);
				[t1 hx_replaceObjectAtIndex:tile.column withObject:tile];
			}
		}
	}
}
- (void) dropTiles{
	
	int _g1 = 0; int _g = PiratePigGame.NUM_COLUMNS;
	while (_g1 < _g) {
		
		int column = _g1++;
		int spaces = 0;
		{
			
			int _g3 = 0; int _g2 = PiratePigGame.NUM_ROWS;
			while (_g3 < _g2) {
				
				int row = _g3++;
				int index = PiratePigGame.NUM_ROWS - 1 - row;
				
				Tile *tile = ((NSMutableArray*)[((NSMutableArray*)[self.tiles hx_objectAtIndex:index]) hx_objectAtIndex:column]);
				if (tile == nil) spaces++;
				else if (spaces > 0) {
					
					CGPoint position = [self getPosition:index + spaces column:column];
					[tile moveTo:0.15 * spaces targetX:position.x targetY:position.y];
					tile.row = index + spaces;
					
					NSMutableArray *t = ((NSMutableArray*)[self.tiles hx_objectAtIndex:index + spaces]);
					[t hx_replaceObjectAtIndex:column withObject:tile];
					t = ((NSMutableArray*)[self.tiles hx_objectAtIndex:index]);
					[t hx_replaceObjectAtIndex:column withObject:[NSNull null]];
					self.needToCheckMatches = YES;
				}
			}
		}
		{
			
			int _g2 = 0;
			while (_g2 < (int)spaces) {
				
				int i = _g2++;
				int row = spaces - 1 - i;
				[self addTile:row column:column animate:YES];
			}
		}
	}
}
- (void) touchesBegan:(NSSet*)touches withEvent:(UIEvent*)withEvent{
	
	
	NSSet *touchesForView = [withEvent touchesForView:self];
	
	UITouch *aTouch = [touchesForView anyObject];
	self.cacheMouse = [aTouch locationInView:self];
	self.cacheMouse =  CGPointMake(self.cacheMouse.x - 10, self.cacheMouse.y - 73 - 20);
	[Log trace:aTouch infos:@{@"fileName":@"PiratePigGame.hx", @"lineNumber":@"406", @"className":@"PiratePigGame", @"methodName":@"touchesBegan"}];
	NSLog(@"cacheMouse %.2fx%.2f", cacheMouse.x, cacheMouse.y);
	if ([touches count] == 1) {
		
		{
			
			int _g1 = 0; int _g = PiratePigGame.NUM_ROWS;
			while (_g1 < _g) {
				
				int i = _g1++;
				{
					
					int _g3 = 0; int _g2 = PiratePigGame.NUM_COLUMNS;
					while (_g3 < _g2) {
						
						int j = _g3++;
						
						Tile *tile = ((NSMutableArray*)[((NSMutableArray*)[self.tiles hx_objectAtIndex:i]) hx_objectAtIndex:j]);
						if ( CGRectContainsPoint(tile.frame, self.cacheMouse)) {
							
							[Log trace:[@"------------------touched something" mutableCopy] infos:@{@"fileName":@"PiratePigGame.hx", @"lineNumber":@"415", @"className":@"PiratePigGame", @"methodName":@"touchesBegan"}];
							NSLog(@"%ix%i %.2f,%.2f %.2fx%.2f", i, j, tile.frame.origin.x, tile.frame.origin.y, tile.frame.size.width, tile.frame.size.height);
							self.selectedTile = tile;
							self.selectedTile.transform =  CGAffineTransformScale(self.selectedTile.transform, 1.4, 1.4);
							return;
						}
						else self.selectedTile = nil;
					}
				}
			}
		}
		if (self.selectedTile == nil) self.cacheMouse = CGPointMake(0,0);
	}
}
- (void) touchesMoved:(NSSet*)touches withEvent:(UIEvent*)withEvent{
	
}
- (void) touchesEnded:(NSSet*)touches withEvent:(UIEvent*)withEvent{
	
	[Log trace:[@"release finger" mutableCopy] infos:@{@"fileName":@"PiratePigGame.hx", @"lineNumber":@"437", @"className":@"PiratePigGame", @"methodName":@"touchesEnded"}];
	self.selectedTile.transform =  CGAffineTransformScale(self.selectedTile.transform, 0.7, 0.7);
	if (! CGPointEqualToPoint(self.cacheMouse, CGPointMake(0,0)) && self.selectedTile != nil && !self.selectedTile.moving) {
		
		
		UITouch *aTouch = [touches anyObject];
		CGPoint pos = [aTouch locationInView:self];
		float differenceX = pos.x - self.cacheMouse.x - 10;
		float differenceY = pos.y - self.cacheMouse.y - 73 - 20;
		if (fabsf(differenceX) > 10 || fabsf(differenceY) > 10) {
			
			int swapToRow = self.selectedTile.row;
			int swapToColumn = self.selectedTile.column;
			if (fabsf(differenceX) > fabsf(differenceY)) {
				
				if (differenceX < 0) swapToColumn--;
				else swapToColumn++;
			}
			else if (differenceY < 0) swapToRow--;
			else swapToRow++;
			[self swapTile:self.selectedTile targetRow:swapToRow targetColumn:swapToColumn];
		}
	}
	self.selectedTile = nil;
	self.cacheMouse = CGPointMake(0,0);
}
- (void) touchesCancelled:(NSSet*)touches withEvent:(UIEvent*)withEvent{
	
}
- (void) loop:(NSTimer*)aTimer{
	
	if (self.needToCheckMatches) {
		
		
		NSMutableArray *matchedTiles = [[NSMutableArray alloc] init];
		matchedTiles = [matchedTiles concat:[self findMatches:YES accumulateScore:nil]];
		matchedTiles = [matchedTiles concat:[self findMatches:NO accumulateScore:nil]];
		
		Tile *tile = nil;
		int i = 0;
		while (i < matchedTiles.length) {
			
			tile = ((NSMutableArray*)[matchedTiles hx_objectAtIndex:i]);
			[self removeTile:tile.row column:tile.column animate:nil];
			i++;
		}
		if (matchedTiles.length > 0) {
			
			self.Score.text = [NSString stringWithFormat:@"%i", currentScore];
			[self dropTiles];
		}
	}
}
- (void) resize:(int)newWidth newHeight:(int)newHeight{
	
	float maxWidth = newWidth * 0.90;
	float maxHeight = newHeight * 0.86;
	self.currentScale = 1;
	float currentWidth = self.frame.size.width;
	float currentHeight = self.frame.size.height;
	if (currentWidth > maxWidth || currentHeight > maxHeight) {
		
		float maxScaleX = maxWidth / currentWidth;
		float maxScaleY = maxHeight / currentHeight;
		if (maxScaleX < maxScaleY) self.currentScale = maxScaleX;
		else self.currentScale = maxScaleY;
	}
	CGRect rect = self.frame;
	rect.origin.x = newWidth / 2 - currentWidth * self.currentScale / 2;
	self.frame = rect;
}
- (id) init{
	
	self = [super init];
	[Log trace:[@"start" mutableCopy] infos:@{@"fileName":@"PiratePigGame.hx", @"lineNumber":@"38", @"className":@"PiratePigGame", @"methodName":@"new"}];
	[self initialize];
	[self construct];
	[self newGame];
	return self;
}

@end
